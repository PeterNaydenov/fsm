import t from"ask-for-promise";import e from"dt-toolbox";import{updateState as n,joinSegments as a,splitSegments as o}from"@peter.naydenov/dt-queries";const i={_setTransitions:function(){return function(t,e){let n={},a={},o={};return t.forEach((t=>{const[i,s,r,c,u]=t,d=e[c],p=`${i}/${s}`;n[p]=d||null,a[p]=r,function(t){return t instanceof Array&&(2==t.length&&(t.forEach((t=>{if(!1!==t||"string"!=typeof t)return!1})),!0))}(u)&&(o[p]=[],o[p][0]=u[0],o[p][1]=u[1])})),{transitions:n,nextState:a,chainActions:o}}},_updateStateData:function(t){return function(e){const{dtbox:n,query:a}=t.dependencies;let o="javascriptObject";return e.export&&(o="dt-object"),e instanceof Array&&e[0][0]===e[0][2]&&e.every((t=>4===t.length))&&(o="dt-model"),"javascriptObject"===o&&e instanceof Array?(console.error("State update failed. Reason: Received an array. Expectation: Object where top-level property name is the name of the data segment."),t.stateData):(["javascriptObject"].includes(o)&&(e=n.init(e).export()),["javascriptObject","dt-model"].includes(o)&&(e=n.load(e)),["javascriptObject","dt-model","dt-object"].includes(o)&&(e=e.query(a.splitSegments)),t.stateData.query(a.updateState,e))}},_updateStep:function(t){return function(e,n,a){const{askForPromise:o}=t.dependencies,i=o(),s=`${t.state}/${n}`,r=t.callback;t.lock=!0,t._transit(i,s,a),i.onComplete((n=>{let a=t._getChain(s),o=n.response;if(n.success){if(t.state=t.nextState[s],null!=n.stateData&&(t.stateData=t._updateStateData(n.stateData)),r.positive.forEach((e=>e(t.state,o))),r.transition.forEach((e=>e(t.state,o))),a&&a[0])return void t._updateStep(e,a[0],o)}else if(r.negative.forEach((e=>e(t.state,o))),r.transition.forEach((e=>e(t.state,o))),a&&a[1])return void t._updateStep(e,a[1],o);e.done(o)})),i.promise.catch((()=>console.log(`Failed in step ${s}`)))}},_warn:function(t){return function(t){Object.entries(t).forEach((([t,e])=>{null==e&&console.log(`Warning: Transition for ${t} is not defined`)}))}},_transit:function(t){return function(){const[e,n,...a]=arguments,{state:o,stateData:i,dependencies:s}=t,r=t.transitions[n],c=t.api.extractList;"function"==typeof r?r({task:e,state:o,extractList:c,dependencies:s},...a):e.done({success:!1})}},_getChain:function(t){return function(e){const n=t.chainActions;return!!n[e]&&n[e]}},_triggerCacheUpdate:function(t){return function(){if(0!==t.cache.length){const{updateTask:e,action:n,dt:a}=t.cache[0];t.cache=t.cache.reduce(((t,e,n)=>(0!=n&&t.push(e),t)),[]),t._updateStep(e,n,a),e.onComplete((e=>t._onUpdateTask(e)))}}},_onUpdateTask:function(t){return function(e){const n=t.callback,a=t.dependencies.askForPromise(n.update);a.each((({value:n,done:a})=>{n(t.state,e),a()})),a.onComplete((e=>{t.lock=!1,t._triggerCacheUpdate()}))}},setDependencies:function(t){return function(e){t.dependencies={...t.dependencies,...e}}},getDependencies:function(t){return function(){return t.dependencies}},on:function(t){return function(e,n){const a=t.callback;a[e]&&a[e].push(n)}},off:function(t){return function(e){t.callback[e]&&(t.callback[e]=[])}},importState:function(t){return function({state:e,stateData:n}){const{dtbox:a,query:o}=t.dependencies;if(e&&(t.state=e,n)){const e=a.load(n).query(o.splitSegments);t.stateData=t.stateData.query(o.updateState,e)}}},exportState:function(t){return function(){const{query:e}=t.dependencies;return{state:t.state,stateData:t.stateData.query(e.joinSegments).export()}}},update:function(t){return function(e,n){const{askForPromise:a}=t.dependencies,o=a();return t.lock?(t.cache.push({updateTask:o,action:e,dt:n}),o.promise):(t._updateStep(o,e,n),o.onComplete((e=>t._onUpdateTask(e))),o.promise)}},reset:function(t){return function(){const{dtbox:e}=t.dependencies;t.state=t.initialState,t.stateData=e.load(t.initialStateData.export())}},ignoreCachedUpdates:function(t){return function(){t.cache.forEach((({updateTask:t,action:e,dt:n})=>t.cancel(`Action '${e}' was ignored`))),t.cache=[]}},getState:function(t){return function(){return t.state}},extractList:function(t){return function(e,n=!1){const a=t.dependencies.query;return 0==arguments.length?t.stateData.query(a.joinSegments).model((()=>({as:"std"}))):n?t.stateData.extractList(e,n):t.stateData.extractList(e,t.stateDataFormat)}}},s=e.getWalk();function r({init:r,behavior:c,stateData:u={},debug:d,stateDataFormat:p={as:"std"}},f={}){const l=this,h={};l.state=r||"N/A",l.initialState=r||"N/A",l.stateDataFormat=p,l.lock=!1,l.cache=[],l.dependencies={walk:s,dtbox:e,askForPromise:t,query:{splitSegments:o,joinSegments:a,updateState:n}},l.callback={update:[],transition:[],positive:[],negative:[]};for(let t in i)t.startsWith("_")?l[t]=i[t](l):h[t]=i[t](l);l.api=h,l.stateData=e.init(u).query(o),l.initialStateData=e.init(u).query(o);const{transitions:m,nextState:g,chainActions:S}=l._setTransitions(c,f);return d&&(l._warn(m),global.debugFSM=l),l.transitions=m,l.nextState=g,l.chainActions=S,h}r.dependencies={walk:s,dtbox:e,askForPromise:t,query:{splitSegments:o,joinSegments:a,updateState:n}};export{r as default};
